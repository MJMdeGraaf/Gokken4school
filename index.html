<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Goksite PWS ‚Äî Multiplayer Blackjack & Poker</title>
  <style>
    /* ============================ LEADERBOARD TAB STYLE ============================ */
    #lb-tab{
        position: fixed;
        right: 20px;
        bottom: 20px;
        background: gold;
        padding: 12px 20px;
        border-radius: 16px;
        cursor: pointer;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(0,0,0,0.4);
        z-index: 9999;
    }

    /* ============================ POPUP WINDOW ============================ */
    #lb-popup{
        position: fixed;
        bottom: 0;
        right: 0;
        width: 360px;
        height: 460px;
        background: rgba(0,0,0,0.88);
        border-radius: 20px 0 0 0;
        display: none;
        z-index: 99999;
        color: white;
    }

    #lb-popup-inner{
        padding: 18px;
        height: 100%;
        position: relative;
    }

    /* ============================ ARROWS ============================ */
    .lb-arrow{
        position: absolute;
        top: 12px;
        font-size: 26px;
        cursor: pointer;
        user-select: none;
    }
    #lb-left{ left: 10px; }
    #lb-right{ right: 10px; }

    /* ============================ CONTENT AREA ============================ */
    #lb-content{
        margin-top: 52px;
        height: 330px;
        overflow-y: auto;
        font-size: 16px;
    }

    #lb-close{
        position: absolute;
        bottom: 14px;
        left: 50%;
        transform: translateX(-50%);
        padding: 8px 20px;
        border-radius: 10px;
        cursor: pointer;
    }

    /* ============================ Music menu style ============================ */
    #musicMenu{
      position: fixed;
      right: 20px;
      bottom: 70px;
      width: 300px;
      background: rgba(0,0,0,0.92);
      color: white;
      padding: 15px;
      border-radius: 12px;
      display: none;
      z-index: 99999;
    }

    #musicMenuInner{
      text-align: center;
    }

    #musicMenu input[type=range]{
      width: 80%;
    }

    /* ============================ Rest of page ============================ */
    body { margin:0; font-family: system-ui, sans-serif; }
    #login, #dashboard, #blackjackSection, #pokerSection { display: none; padding: 20px; text-align:center; }
    #login { background: #f0f0f0; height:100vh; display:flex; flex-direction:column; justify-content:center; align-items:center; gap:8px; }
    #dashboard { background: linear-gradient(to bottom, #ffffff, #e0e0e0); height:100vh; }
    #dashboard h2, #login h2 { margin-bottom:10px; }
    button { padding: 10px 14px; margin: 6px; border-radius: 8px; border:none; cursor:pointer; }

    /* Blackjack sectie */
    #blackjackSection {
      height:100vh;
      color:white;
      background:
        radial-gradient(circle at 20% 0%, rgba(255,255,255,0.08), transparent 55%),
        radial-gradient(circle at 80% 100%, rgba(255,255,255,0.04), transparent 55%),
        radial-gradient(circle at center, #1c7b52 0, #094432 55%, #031614 100%);
    }
    .table-container {
      position:relative;
      width: 90%;
      max-width: 900px;
      margin: 36px auto;
      height:520px;
      perspective: 900px;
    }
    .table {
      position:relative;
      width:100%;
      height:100%;
      border-radius: 50%;
      background:
        radial-gradient(circle at 30% 20%, #2fbf7a 0, #12724b 45%, #063024 100%);
      box-shadow:
        0 18px 40px rgba(0,0,0,0.8),
        inset 0 0 25px rgba(0,0,0,0.85);
      border: 8px solid #c59b45;
      transform: rotateX(18deg);
      transform-origin: center 120%;
    }
    .table::before{
      content:'';
      position:absolute;
      inset:18%;
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.15);
      box-shadow:0 0 12px rgba(0,0,0,0.7);
      pointer-events:none;
    }
    .player-area {
      position:absolute;
      text-align:center;
      color: white;
      width:160px;
      transform:translateX(-50%);
      pointer-events:none;
      font-size:14px;
    }
    .player-area h3{
      margin:0;
      padding:0;
      font-size:15px;
    }
    .player-area p{
      margin:2px 0 0 0;
      font-size:13px;
    }
    .cards {
      display:flex;
      justify-content:center;
      gap:6px;
      margin-top:6px;
      flex-wrap:nowrap;
    }
    .card-bj {
      width:80px;
      height:120px;
      border-radius:12px;
      display:flex;
      justify-content:center;
      align-items:center;
      font-weight:bold;
      font-size:22px;
      color:#111;
      border:2px solid #caa84a;
      box-shadow:0 6px 14px rgba(0,0,0,0.7);
      background:
        repeating-linear-gradient(
          45deg,
          #fdfdfd,
          #fdfdfd 6px,
          #f5f5f5 6px,
          #f5f5f5 12px
        );
    }
    .card-back {
      width:80px;
      height:120px;
      border-radius:12px;
      border:2px solid #caa84a;
      box-shadow:0 6px 14px rgba(0,0,0,0.7);
      background:
        repeating-linear-gradient(
          45deg,
          #e0c15a,
          #e0c15a 8px,
          #2b2210 8px,
          #2b2210 16px
        );
    }
    .chair {
      width:50px;
      height:50px;
      background:radial-gradient(circle at 30% 20%, #555, #222);
      border-radius:50%;
      position:absolute;
      box-shadow:
        0 4px 10px rgba(0,0,0,0.6),
        inset 0 -4px 8px rgba(0,0,0,0.8);
      border:2px solid #666;
    }
    #controls { margin-top:20px; }


/* Poker section */
    #pokerSection { background:#0f2b2a; min-height:100vh; color:white; padding-bottom:40px; }
    .poker-table { width:90%; max-width:1000px; margin:20px auto; background:linear-gradient(#0b6b5a,#084d3f); border-radius:12px; padding:18px; box-shadow:0 8px 30px rgba(0,0,0,0.5); }
    .community { display:flex; justify-content:center; gap:8px; margin:12px 0; }
    .card-pk { width:72px; height:102px; background:white; color:black; border-radius:6px; display:flex; justify-content:center; align-items:center; font-weight:bold; }
    .seat-row { display:flex; justify-content:space-around; align-items:center; margin:12px 0; }
    .seat { width:140px; text-align:center; }
    .small { font-size:12px; color:#ddd; }

    .poker-controls { margin-top:14px; }

    /* small responsive */
    @media (max-width:600px){
      #lb-popup { width: 100%; right:0; left:0; height: 50vh; border-radius: 12px 12px 0 0;}
      .card-bj{ width:56px; height:84px; }
      .table-container{ height:360px; }
      .card-pk{ width:48px; height:68px; font-size:12px; }
    }
  </style>
</head>
<body>

  <!-- Global credits overlay -->
  <div id="creditsDisplayGlobal" style="display:none;position:fixed;top:12px;left:12px;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:8px;font-size:16px;z-index:99999;">
    Credits: <span id="globalCredits">0</span>
  </div>


  <!-- Login / Account aanmaken -->
  <section id="login">
    <h2>Welkom! Maak een account of log in</h2>
    <input type="text" id="usernameInput" placeholder="Gebruikersnaam">
    <input type="password" id="passwordInput" placeholder="Wachtwoord">
    <button id="loginBtn">Login</button>
    <button id="createAccountBtn">Account aanmaken</button>
  </section>

  <!-- Dashboard -->
  <section id="dashboard">
    <h2>Welkom, <span id="displayName"></span></h2>
    <p>Credits: <span id="credits"></span></p>
    <button id="claimDailyBtn">Claim dagelijkse bonus</button><br>
    <button id="playBlackjackBtn">Speel Blackjack</button>
    <button id="playPokerBtn">Speel Poker (Texas Hold'em)</button>
    <button id="openLeaderboardsBtn">Leaderboards</button>
    <button id="logoutBtn">Uitloggen</button>

    <!-- Music control -->
    <div style="margin-top:12px;">
      <audio id="bgMusic" loop>
        <source src="https://cdn.pixabay.com/audio/2023/03/07/audio_2ea36d1deb.mp3" type="audio/mpeg">
        <source src="https://cdn.pixabay.com/audio/2023/03/15/audio_e3bbcbfce7.mp3" type="audio/mpeg">
        <source src="https://cdn.pixabay.com/audio/2022/03/15/audio_8f17fc4b42.mp3" type="audio/mpeg">
      </audio>
      <button id="musicControl">üéµ Muziek</button>
    </div>
  </section>

  <!-- Blackjack -->
  <section id="blackjackSection">
    <h2>Blackjack</h2>
    <div>
      <label>Kies aantal bots:</label>
      <select id="botCount">
        <option value="0">0 bots</option>
        <option value="1">1 bot</option>
        <option value="2">2 bots</option>
        <option value="3">3 bots</option>
        <option value="4">4 bots</option>
        <option value="5">5 bots</option>
        <option value="6">6 bots</option>
        <option value="7">7 bots</option>
      </select><br><br>
      <label>Inzet (credits):</label>
      <input type="number" id="betAmount" min="1" value="100">
      <button id="startGame">Start spel</button>
      <button id="backToMenu">Terug naar menu</button>
    </div>
    <div class="table-container">
      <div class="table" id="table">
        <!-- Stoelen + spelergebieden komen hier dynamisch -->
      </div>
    </div>
    <div id="controls">
      <button id="hitBtn">Hit</button>
      <button id="standBtn">Stand</button>
      <button id="nextRoundBtn" style="display:none">Volgende ronde</button>
    </div>
  </section>

  <!-- Poker Section (new) -->
  <section id="pokerSection">
    <h2>Texas Hold'em (No-Limit)</h2>
    <div class="poker-table" id="pokerTable">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <label>Max spelers (incl. jij):</label>
          <select id="pokerPlayers">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4" selected>4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
          </select>
          <label style="margin-left:10px">Start stack:</label>
          <input id="pokerStartStack" type="number" value="1000" min="100">
        </div>
        <div>
          <button id="joinPokerBtn">Maak/Treed bij tafel</button>
          <button id="leavePokerBtn">Verlaat tafel</button>
          <button id="startPokerHandBtn">Start hand</button>
          <button id="backFromPoker">Terug naar menu</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        Pot: <span id="pokerPot">0</span> &nbsp;|&nbsp; Side pots: <span id="pokerSidePots">-</span>
      </div>

      <div class="seat-row" id="pokerSeats">
        <!-- Seats rendered here -->
      </div>

      <div style="text-align:center;margin-top:8px;">
        <div class="community" id="communityCards"></div>
      </div>

      <div style="text-align:center;margin-top:6px;">
        Actieve speler: <span id="activePokerPlayer">-</span> &nbsp;|&nbsp; To call: <span id="toCallDisplay">0</span>
      </div>

      <div class="poker-controls" style="text-align:center;">
        <button id="foldBtn">Fold</button>
        <button id="callBtn">Call</button>
        <input id="raiseInput" type="number" style="width:100px" placeholder="Raise amount">
        <button id="raiseBtn">Raise</button>
        <button id="allinBtn">All-in</button>
      </div>

      <div style="margin-top:10px;text-align:center;" class="small">
        <div id="pokerLog"></div>
      </div>
    </div>
  </section>

  <!-- Leaderboard floating tab -->
  <div id="lb-tab">üèÜ Leaderboard</div>

  <!-- Leaderboard popup -->
  <div id="lb-popup">
      <div id="lb-popup-inner">
          <div id="lb-left" class="lb-arrow">‚Üê</div>
          <h2 id="lb-title">All-Time Earnings</h2>
          <div id="lb-content"></div>
          <div id="lb-right" class="lb-arrow">‚Üí</div>
          <button id="lb-close">Sluiten</button>
      </div>
  </div>

  <!-- MUSIC MENU -->
  <div id="musicMenu">
    <div id="musicMenuInner">
        <h3>Muziekinstellingen</h3>
        <label>Volume:</label><br>
        <input type="range" id="musicVolume" min="0" max="1" step="0.01">
        <br><br>
        <label>Muziek selecteren:</label>
        <select id="musicTrackSelect">
            <option value="0">Funky Upbeat</option>
            <option value="1">Electronic Chill</option>
            <option value="2">Lounge Vibes</option>
        </select>
        <br><br>
        <button id="muteBtn">üéµ Mute</button>
        <br><br>
        <button id="closeMusicMenu">Sluiten</button>
    </div>
  </div>

  <script>
    /* ---------------------------
       Existing app code (unchanged) + small fixes
       --------------------------- */
    let users = JSON.parse(localStorage.getItem('users') || '{}');
    let currentUser = null;
    function saveUsers(){ localStorage.setItem('users', JSON.stringify(users)); }
    function keyForName(name){ return name.trim().toLowerCase(); }

    // UI refs
    const loginSection = document.getElementById('login');
    const dashboard = document.getElementById('dashboard');
    const blackjackSection = document.getElementById('blackjackSection');
    const pokerSection = document.getElementById('pokerSection');

    const usernameInput = document.getElementById('usernameInput');
    const passwordInput = document.getElementById('passwordInput');
    const loginBtn = document.getElementById('loginBtn');
    const createAccountBtn = document.getElementById('createAccountBtn');
    const displayName = document.getElementById('displayName');
    const creditsEl = document.getElementById('credits');
    const globalCreditsEl = document.getElementById('globalCredits');
    const creditsOverlay = document.getElementById('creditsDisplayGlobal');
    const claimDailyBtn = document.getElementById('claimDailyBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const playBlackjackBtn = document.getElementById('playBlackjackBtn');
    const playPokerBtn = document.getElementById('playPokerBtn');
    const openLeaderboardsBtn = document.getElementById('openLeaderboardsBtn');

    const bgMusic = document.getElementById('bgMusic');
    const musicControl = document.getElementById('musicControl');
    const musicMenu = document.getElementById('musicMenu');
    const musicVolume = document.getElementById('musicVolume');
    const musicTrackSelect = document.getElementById('musicTrackSelect');
    const closeMusicMenu = document.getElementById('closeMusicMenu');
    const muteBtn = document.getElementById('muteBtn');

    // Blackjack refs (unchanged)
    const startGameBtn = document.getElementById('startGame');
    const botSelect = document.getElementById('botCount');
    const betAmountInput = document.getElementById('betAmount');
    const table = document.getElementById('table');
    const hitBtn = document.getElementById('hitBtn');
    const standBtn = document.getElementById('standBtn');
    const nextRoundBtn = document.getElementById('nextRoundBtn');
    const backToMenuBtn = document.getElementById('backToMenu');

    // Leaderboard refs
    const lbTab = document.getElementById('lb-tab');
    const lbPopup = document.getElementById('lb-popup');
    const lbLeft = document.getElementById('lb-left');
    const lbRight = document.getElementById('lb-right');
    const lbClose = document.getElementById('lb-close');
    const lbTitle = document.getElementById('lb-title');
    const lbContent = document.getElementById('lb-content');

    // Poker refs (new)
    const playPokerBtnEl = document.getElementById('playPokerBtn');
    const pokerPlayersSelect = document.getElementById('pokerPlayers');
    const pokerStartStackInput = document.getElementById('pokerStartStack');
    const joinPokerBtn = document.getElementById('joinPokerBtn');
    const leavePokerBtn = document.getElementById('leavePokerBtn');
    const startPokerHandBtn = document.getElementById('startPokerHandBtn');
    const backFromPoker = document.getElementById('backFromPoker');

    const pokerSeatsDiv = document.getElementById('pokerSeats');
    const communityCardsDiv = document.getElementById('communityCards');
    const pokerPotSpan = document.getElementById('pokerPot');
    const pokerSidePotsSpan = document.getElementById('pokerSidePots');
    const activePokerPlayerSpan = document.getElementById('activePokerPlayer');
    const toCallDisplay = document.getElementById('toCallDisplay');
    const foldBtn = document.getElementById('foldBtn');
    const callBtn = document.getElementById('callBtn');
    const raiseInput = document.getElementById('raiseInput');
    const raiseBtn = document.getElementById('raiseBtn');
    const allinBtn = document.getElementById('allinBtn');
    const pokerLog = document.getElementById('pokerLog');

    // small helpers
    function showLog(msg){ pokerLog.innerHTML = (pokerLog.innerHTML + '<div>'+msg+'</div>').slice(-8000); /* keep small */ }

    /* ---------------------------
       Login / accounts (unchanged)
       --------------------------- */
    loginBtn.onclick = ()=>{
        const nameKey = keyForName(usernameInput.value);
        const password = passwordInput.value;
        if(!nameKey || !password) return alert('Vul gebruikersnaam en wachtwoord in.');
        if(!users[nameKey]) return alert('Account bestaat niet.');
        if(users[nameKey].password !== password) return alert('Wachtwoord verkeerd.');
        currentUser = users[nameKey];
        if(!currentUser.key) currentUser.key = nameKey;
        saveUsers();
        loginSection.style.display='none';
        dashboard.style.display='block';
        renderDashboard();
        bgMusic.play().catch(()=>{});
    };

    createAccountBtn.onclick = ()=>{
        const nameKey = keyForName(usernameInput.value);
        const password = passwordInput.value;
        if(!nameKey || !password) return alert('Vul gebruikersnaam en wachtwoord in.');
        if(users[nameKey]) return alert('Account bestaat al.');
        users[nameKey] = {
            name: usernameInput.value.trim(),
            password: password,
            credits: 500,
            lastDaily: null,
            wins: 0,
            losses: 0,
            totalEarned: 0,
            gamesPlayed: 0,
            key: nameKey
        };
        currentUser = users[nameKey];
        saveUsers();
        loginSection.style.display='none';
        dashboard.style.display='block';
        renderDashboard();
        bgMusic.play().catch(()=>{});
    };

    function renderDashboard(){
      if(!currentUser){
        if(creditsOverlay) creditsOverlay.style.display = 'none';
        return;
      }
      displayName.textContent = currentUser.name;
      creditsEl.textContent = currentUser.credits;
      if(globalCreditsEl){
        globalCreditsEl.textContent = currentUser.credits;
      }
      if(creditsOverlay){
        creditsOverlay.style.display = 'block';
      }
    }
}

    logoutBtn.onclick = () => {
      currentUser = null;
      dashboard.style.display = 'none';
      loginSection.style.display = 'flex';
      bgMusic.pause();
      if(creditsOverlay){
        creditsOverlay.style.display = 'none';
      }
    };


    claimDailyBtn.onclick = ()=>{
      if(!currentUser) return;
      const t = new Date().toDateString();
      if(currentUser.lastDaily !== t){
        currentUser.credits += 100;
        currentUser.lastDaily = t;
        users[currentUser.key] = currentUser;
        saveUsers();
        renderDashboard();
        alert('Dagelijkse bonus geclaimd: +100 credits');
      } else {
        alert('Je hebt vandaag al je bonus geclaimd.');
      }
    };

    playBlackjackBtn.onclick = ()=>{
      dashboard.style.display='none';
      blackjackSection.style.display='block';
    };

    backToMenuBtn.onclick = ()=>{
      blackjackSection.style.display='none';
      dashboard.style.display='block';
    };

    playPokerBtnEl.onclick = ()=>{
      dashboard.style.display='none';
      pokerSection.style.display='block';
    };

    backFromPoker.onclick = ()=>{
      pokerSection.style.display='none';
      dashboard.style.display='block';
    };

    // Leaderboards (unchanged)
    let lbIndex = 0;
    const lbTypes = ['earnings','winrate'];
    function loadUsersArray(){ return Object.entries(users).map(([k,u])=>({ key:k, name:u.name, totalEarned:u.totalEarned||0, wins:u.wins||0, losses:u.losses||0, games:u.gamesPlayed||0 })); }
    function openLeaderboard(){
      lbPopup.style.display='block';
      const type = lbTypes[lbIndex];
      lbTitle.textContent = type==='earnings'?'All-Time Earnings':'Win Percentage';
      const arr=loadUsersArray();
      if(type==='earnings'){ arr.sort((a,b)=>b.totalEarned-a.totalEarned); }
      else { arr.sort((a,b)=>{ const ra=a.games?(a.wins/a.games):0; const rb=b.games?(b.wins/b.games):0; return rb-ra; }); }
      let html='';
      const top=arr.slice(0,10);
      top.forEach((u,i)=>{ const isYou=currentUser && (u.key===currentUser.key); html+=`<div style="padding:6px 0">${i+1}. <strong>${u.name}</strong> ${isYou?'<em>(jij)</em>':''} ${type==='earnings'?('‚Äî '+u.totalEarned+' credits'):('‚Äî '+(u.games?Math.round(100*u.wins/u.games):0)+'%')}</div>`; });
      let yourRank=-1; if(currentUser) yourRank=arr.findIndex(x=>x.key===currentUser.key);
      if(yourRank>9){ const u=arr[yourRank]; html+=`<hr><div style="padding:6px 0">${yourRank+1}. <strong>${u.name}</strong> ${type==='earnings'?('‚Äî '+u.totalEarned+' credits'):('‚Äî '+(u.games?Math.round(100*u.wins/u.games):0)+'%')}</div>`; }
      else if(yourRank===-1 && currentUser){ html+=`<hr><div style="padding:6px 0">Jij staat nog niet in de statistieken.</div>`; }
      lbContent.innerHTML=html;
    }
    lbTab.onclick = ()=>{ lbIndex=0; openLeaderboard(); };
    lbClose.onclick = ()=>{ lbPopup.style.display='none'; };
    lbLeft.onclick = ()=>{ lbIndex=(lbIndex-1+lbTypes.length)%lbTypes.length; openLeaderboard(); };
    lbRight.onclick = ()=>{ lbIndex=(lbIndex+1)%lbTypes.length; openLeaderboard(); };
    openLeaderboardsBtn.onclick = ()=>{ lbIndex = 0; openLeaderboard(); };

    // Music menu (unchanged logic)
    musicVolume.value = 0.4;
    bgMusic.volume = 0.4;
    musicControl.onclick = () => { musicMenu.style.display = (musicMenu.style.display==='block'?'none':'block'); };
    musicVolume.oninput = ()=>{ bgMusic.volume = parseFloat(musicVolume.value); };
    musicTrackSelect.onchange = ()=>{
      const index = parseInt(musicTrackSelect.value);
      const sources = bgMusic.querySelectorAll('source');
      if(sources[index]){
        bgMusic.pause();
        bgMusic.src = sources[index].src;
        bgMusic.load();
        bgMusic.play().catch(()=>{});
      }
    };
    muteBtn.onclick = ()=>{ bgMusic.muted = !bgMusic.muted; muteBtn.textContent = bgMusic.muted ? 'üîá Unmute' : 'üéµ Mute'; };
    closeMusicMenu.onclick = ()=>{ musicMenu.style.display='none'; };

    /* ---------------------------
       Blackjack code left intact (unchanged)
       --------------------------- */
    const suits=['‚ô†','‚ô•','‚ô¶','‚ô£'];
    const values=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    let deck=[];
    function createDeck(){ deck=[]; for(let s of suits) for(let v of values) deck.push({suit:s, value:v}); for(let i=deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; } }
    function cardValue(card){ if(['J','Q','K'].includes(card.value)) return 10; if(card.value==='A') return 11; return parseInt(card.value); }
    function handValue(hand){ let total=0, aces=0; for(let c of hand){ total+=cardValue(c); if(c.value==='A') aces++; } while(total>21 && aces>0){ total-=10; aces--; } return total; }
    function drawCard(){ return deck.pop(); }

    let players=[]; // blackjack players
    let dealer={hand:[], name:'Dealer'};
    let currentPlayerIndex=0;
    let currentBet = 100;

    
    function placePlayers(){
      table.innerHTML = '';
      const centerX = table.clientWidth/2;
      const centerY = table.clientHeight/2;
      const kaartWidth = 80;
      const kaartHeight = 120;
      const radius = table.clientWidth * 0.42;

      const dealerAngle = -Math.PI/2;   // boven
      const playerAngle =  Math.PI/2;   // onder
      const botAngles = [
        -3*Math.PI/4,   // links-boven
        Math.PI,        // links
        3*Math.PI/4,    // links-onder
        Math.PI/4,      // rechts-onder
        0,              // rechts
        -Math.PI/4      // rechts-boven
      ];

      function pos(angle){
        return {
          x: centerX + Math.cos(angle)*radius,
          y: centerY + Math.sin(angle)*radius*0.7
        };
      }

      // Dealer
      const dPos = pos(dealerAngle);
      const dealerDiv = document.createElement('div');
      dealerDiv.className='player-area';
      dealerDiv.style.left = dPos.x + 'px';
      dealerDiv.style.top = (dPos.y - kaartHeight/2) + 'px';
      dealerDiv.innerHTML = `
        <h3>Dealer</h3>
        <div class='cards'>
          ${dealer.hand.map(c=>`<div class='card-bj'>${c.value}${c.suit}</div>`).join('')}
        </div>
        <p>Score: ${handValue(dealer.hand)}</p>
      `;
      const dealerChair = document.createElement('div');
      dealerChair.className='chair';
      dealerChair.style.left = (dPos.x - 25) + 'px';
      dealerChair.style.top  = (dPos.y + kaartHeight/2 - 10) + 'px';
      table.appendChild(dealerChair);
      table.appendChild(dealerDiv);

      // Speler (altijd index 0)
      if(players.length > 0){
        const pPos = pos(playerAngle);
        const pDiv = document.createElement('div');
        pDiv.className='player-area';
        pDiv.style.left = pPos.x + 'px';
        pDiv.style.top  = (pPos.y - kaartHeight/2) + 'px';
        pDiv.innerHTML = `
          <h3>${players[0].name} ${currentPlayerIndex===0?'‚Üê':''}</h3>
          <div class='cards'>
            ${players[0].hand.map(c=>`<div class='card-bj'>${c.value}${c.suit}</div>`).join('')}
          </div>
          <p>Score: ${handValue(players[0].hand)}</p>
        `;
        const pChair = document.createElement('div');
        pChair.className='chair';
        pChair.style.left = (pPos.x - 25) + 'px';
        pChair.style.top  = (pPos.y + kaartHeight/2 - 10) + 'px';
        table.appendChild(pChair);
        table.appendChild(pDiv);
      }

      // Bots
      const botCount = Math.max(0, players.length - 1);
      const botAnglesUsed = botAngles.slice(0, botCount);
      for(let i=1;i<players.length;i++){
        const a = botAnglesUsed[i-1];
        const bPos = pos(a);
        const bDiv = document.createElement('div');
        bDiv.className='player-area';
        bDiv.style.left = bPos.x + 'px';
        bDiv.style.top  = (bPos.y - kaartHeight/2) + 'px';
        bDiv.innerHTML = `
          <h3>${players[i].name}</h3>
          <div class='cards'>
            ${players[i].hand.map(c=>`<div class='card-bj'>${c.value}${c.suit}</div>`).join('')}
          </div>
          <p>Score: ${handValue(players[i].hand)}</p>
        `;
        const bChair = document.createElement('div');
        bChair.className='chair';
        bChair.style.left = (bPos.x - 25) + 'px';
        bChair.style.top  = (bPos.y + kaartHeight/2 - 10) + 'px';
        table.appendChild(bChair);
        table.appendChild(bDiv);
      }
    }


    function renderGame(){ placePlayers(); }

    function nextPlayer(){
      currentPlayerIndex++;
      if(currentPlayerIndex >= players.length){
        dealerTurn();
      } else if(players[currentPlayerIndex].bot){
        botTurn(players[currentPlayerIndex]);
      }
      renderGame();
    }

    function botTurn(bot){
      let hv = handValue(bot.hand);
      while(hv<16){
        bot.hand.push(drawCard());
        hv=handValue(bot.hand);
      }
      nextPlayer();
    }

    function dealerTurn(){
      let hv = handValue(dealer.hand);
      while(hv<17){
        dealer.hand.push(drawCard());
        hv=handValue(dealer.hand);
      }
      checkWinners();
    }

    function checkWinners(){
      const dealerScore=handValue(dealer.hand);
      let resultMsg=`Dealer heeft ${dealerScore}.\n`;
      for(let i=0;i<players.length;i++){
        const p=players[i];
        const ps=handValue(p.hand);
        let outcome='lose';
        if(ps>21){
          resultMsg+=`${p.name} verliest (bust).\n`;
          outcome='lose';
        } else if(dealerScore>21 || ps>dealerScore){
          resultMsg+=`${p.name} wint!\n`;
          outcome='win';
        } else if(ps===dealerScore){
          resultMsg+=`${p.name} gelijkspel.\n`;
          outcome='push';
        } else{
          resultMsg+=`${p.name} verliest.\n`;
          outcome='lose';
        }
        if(i===0 && currentUser){
          let delta = 0;
          if(outcome==='win') delta = Math.floor(currentBet*1.5);
          else if(outcome==='push') delta = Math.floor(currentBet*1.0);
          else delta = 0;
          currentUser.credits += delta;
          currentUser.gamesPlayed = (currentUser.gamesPlayed||0)+1;
          if(outcome==='win'){ currentUser.wins=(currentUser.wins||0)+1; currentUser.totalEarned=(currentUser.totalEarned||0)+delta; }
          else if(outcome==='lose'){ currentUser.losses=(currentUser.losses||0)+1; currentUser.totalEarned=(currentUser.totalEarned||0); }
          else if(outcome==='push'){ /* totalEarned unchanged */ }
          users[currentUser.key]=currentUser;
          saveUsers();
          renderDashboard();
        }
      }
      alert(resultMsg);
      nextRoundBtn.style.display='inline';
      hitBtn.style.display='none';
      standBtn.style.display='none';
    }

    function startRound(){
      currentBet = Math.min(currentUser.credits, parseInt(betAmountInput.value)||100);
      createDeck();
      dealer.hand=[drawCard(), drawCard()];
      players.forEach(p=>p.hand=[drawCard(), drawCard()]);
      currentPlayerIndex=0;
      renderGame();
      if(players[0].bot) botTurn(players[0]);
      hitBtn.style.display='inline';
      standBtn.style.display='inline';
    }

 startGameBtn.onclick = ()=>{
  if(!currentUser) return alert('Je moet eerst inloggen!');

  // bepaal inzet
  currentBet = Math.min(currentUser.credits, parseInt(betAmountInput.value)||100);
  if(currentUser.credits < currentBet) return alert('Je hebt niet genoeg credits!');

  // trek inzet direct af
  currentUser.credits -= currentBet;
  saveUsers();
  renderDashboard();

  // maak spelers array: eerste element is menselijke speler
  players = [{ name:currentUser.name, bot:false, hand:[] }];

  // voeg bots toe gebaseerd op selectie
  const botCount = parseInt(botSelect.value);
  for(let i=1; i<=botCount; i++) players.push({ name:`Bot ${i}`, bot:true, hand:[] });

  // start ronde
  startRound();
    };

    hitBtn.onclick = ()=>{
      const p = players[currentPlayerIndex];
      p.hand.push(drawCard());
      if(handValue(p.hand)>21) nextPlayer();
      renderGame();
    };

    standBtn.onclick = ()=>{ nextPlayer(); };
    nextRoundBtn.onclick = ()=>{ nextRoundBtn.style.display='none'; startRound(); };

    /* ---------------------------
       Poker module (new)
       - No-limit Texas Hold'em
       - Pot & side-pot calculation + payout
       - Basic UI & smart bots (level 3 heuristic)
       --------------------------- */

    // Poker deck / utils
    const PK_suits = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
    const PK_values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    function PK_newDeck(){ const d=[]; for(const s of PK_suits) for(const v of PK_values) d.push({suit:s,value:v}); for(let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]];} return d; }
    function PK_valNum(v){ if(v==='A') return 14; if(v==='K') return 13; if(v==='Q') return 12; if(v==='J') return 11; return parseInt(v); }
    function PK_cardText(c){ return c? (c.value + c.suit) : '??'; }

    // Poker state
    let PK_table = {
      seats: [],     // array of player objects or null for empty seats
      deck: [],
      community: [],
      dealerIndex: 0,
      toAct: 0,
      toCall: 0,
      potObjects: [], // computed pots
      running: false,
      minPlayers: 2
    };

    // Create seats (max players)
    function PK_resetTable(){
      const maxPlayers = parseInt(pokerPlayersSelect.value);
      PK_table.seats = [];
      for(let i=0;i<maxPlayers;i++) PK_table.seats.push(null);
      PK_renderSeats();
      PK_resetRoundState();
      showLog('Tafel gereset voor '+maxPlayers+' spelers.');
    }

    function PK_resetRoundState(){
      PK_table.deck = [];
      PK_table.community = [];
      PK_table.potObjects = [];
      PK_table.running = false;
      pokerPotSpan.textContent = '0';
      pokerSidePotsSpan.textContent = '-';
      communityCardsDiv.innerHTML = '';
      activePokerPlayerSpan.textContent = '-';
      toCallDisplay.textContent = '0';
      pokerLog.innerHTML = '';
    }

    // Join/leave
    joinPokerBtn.onclick = ()=>{
      if(!currentUser) return alert('Login eerst.');
      // join first empty seat
      const idx = PK_table.seats.findIndex(s => s===null);
      if(idx===-1) return alert('Tafel is vol.');
      // create player object
      const startStack = Math.max(1, parseInt(pokerStartStackInput.value)||1000);
      const player = {
        key: currentUser.key,
        name: currentUser.name,
        stack: startStack,
        hand: [],
        bet: 0,
        committed: 0,
        folded: false,
        allIn: false,
        isBot: false,
        seat: idx
      };
      PK_table.seats[idx] = player;
      PK_renderSeats();
      showLog(`${player.name} nam plaats ${idx+1}`);
    };

    leavePokerBtn.onclick = ()=>{
      if(!currentUser) return alert('Login eerst.');
      const idx = PK_table.seats.findIndex(s => s && s.key === currentUser.key);
      if(idx===-1) return alert('Je zit niet aan de tafel.');
      PK_table.seats[idx] = null;
      PK_renderSeats();
    };

    // Start a hand
    startPokerHandBtn.onclick = ()=>{
      // must have at least 2 players seated
      const joined = PK_table.seats.filter(s => s!==null);
      if(joined.length < 2) return alert('Minstens 2 spelers nodig om te starten.');
      // reset deck & community
      PK_table.deck = PK_newDeck();
      PK_table.community = [];
      PK_table.potObjects = [];
      // reset player per-hand properties and set seat indices
      for(let i=0;i<PK_table.seats.length;i++){
        if(PK_table.seats[i]){
          PK_table.seats[i].hand = [];
          PK_table.seats[i].bet = 0;
          PK_table.seats[i].committed = 0;
          PK_table.seats[i].folded = false;
          PK_table.seats[i].allIn = false;
          PK_table.seats[i].seat = i;
        }
      }
      // deal two cards to each seated player
      for(let r=0;r<2;r++){
        for(let i=0;i<PK_table.seats.length;i++){
          if(PK_table.seats[i]) PK_table.seats[i].hand.push(PK_table.deck.pop());
        }
      }
      // set dealerIndex to next non-null seat (rotate)
      PK_table.dealerIndex = PK_table.dealerIndex % PK_table.seats.length;
      // ensure dealer points to a real player
      let di = PK_table.dealerIndex;
      while(!PK_table.seats[di]) di = (di+1)%PK_table.seats.length;
      PK_table.dealerIndex = di;

      // blinds: small blind (SB) is next seat, big blind next
      const sbIndex = PK_nextOccupiedIndex(PK_table.dealerIndex, 1);
      const bbIndex = PK_nextOccupiedIndex(PK_table.dealerIndex, 2);
      const sb = PK_table.seats[sbIndex];
      const bb = PK_table.seats[bbIndex];
      const sbAmt = Math.max(1, Math.floor( (pokerStartStackInput.value || 1000) * 0.01 )); // 1% default
      const bbAmt = sbAmt*2;
      // post blinds from stacks (no negative)
      if(sb){
        const actual = Math.min(sbAmt, sb.stack);
        sb.stack -= actual; sb.bet += actual; sb.committed += actual; if(sb.stack===0) sb.allIn=true;
      }
      if(bb){
        const actual2 = Math.min(bbAmt, bb.stack);
        bb.stack -= actual2; bb.bet += actual2; bb.committed += actual2; if(bb.stack===0) bb.allIn=true;
      }

      PK_table.toCall = bb ? bb.bet : 0;
      PK_table.toAct = PK_nextOccupiedIndex(PK_table.dealerIndex, 3); // first to act preflop is UTG (after BB)
      PK_table.running = true;

      // render
      PK_renderSeats();
      PK_updateUI();
      showLog('Hand gestart. Blinds geplaatst: SB '+sbAmt+' BB '+bbAmt);
      // start betting round preflop
      setTimeout(()=> PK_runBettingRound('preflop'), 300);
    };

    // helper to find next occupied seat offset from idx by step; step relative seats ahead
    function PK_nextOccupiedIndex(fromIdx, step){
      const n = PK_table.seats.length;
      let i = fromIdx;
      for(let s=0;s< n; s++){
        i = (i+1)%n;
        if(PK_table.seats[i]) {
          step--;
          if(step<=0) return i;
        }
      }
      // fallback: find any occupied
      return PK_table.seats.findIndex(s=>s!==null);
    }

    // Render seats UI
    function PK_renderSeats(){
      pokerSeatsDiv.innerHTML = '';
      for(let i=0;i<PK_table.seats.length;i++){
        const s = document.createElement('div');
        s.className = 'seat';
        const data = PK_table.seats[i];
        if(data){
          s.innerHTML = `<div><strong>${data.name}</strong></div>
                         <div class="small">Seat ${i+1}</div>
                         <div class="small">Stack: ${data.stack}</div>
                         <div class="small">${data.folded?'<em>Folded</em>':(data.allIn?'<em>All-in</em>':'')}</div>
                         <div style="margin-top:6px;">${data.hand.map(c=>`<div class="card-pk">${PK_cardText(c)}</div>`).join('')}</div>`;
        } else {
          s.innerHTML = `<div style="opacity:0.7">Leeg</div><div class="small">Seat ${i+1}</div>`;
        }
        pokerSeatsDiv.appendChild(s);
      }
    }

    // Betting round controller (no-limit) - simplified synchronous loop
    async function PK_runBettingRound(stage){
      // stage: 'preflop','flop','turn','river'
      if(!PK_table.running) return;
      showLog('Betting round: '+stage);
      // reset per-player bet (we track bets by .bet already committed)
      // we use a simple while-loop over active players until betting is closed
      let playersInHand = PK_table.seats.filter(s=>s && !s.folded);
      if(playersInHand.length<=1){
        // trivial: immediate showdown
        PK_finishHand();
        return;
      }
      // determine initial toCall = current max bet among players
      let maxBet = 0;
      for(const p of PK_table.seats) if(p) maxBet = Math.max(maxBet, p.bet||0);
      PK_table.toCall = maxBet;
      toCallDisplay.textContent = PK_table.toCall;
      // start from toAct (already set)
      let idx = PK_table.toAct;
      // We'll loop until everyone has acted with no new raises
      let lastRaiser = null;
      let acted = new Set();
      // Note: bots act immediately, human uses UI buttons
      while(true){
        // find next active seat
        if(!PK_table.seats[idx] || PK_table.seats[idx].folded || PK_table.seats[idx].allIn){
          idx = (idx+1)%PK_table.seats.length;
          continue;
        }
        const player = PK_table.seats[idx];
        activePokerPlayerSpan.textContent = player.name;
        toCallDisplay.textContent = PK_table.toCall - (player.bet||0);
        PK_updateUI();
        // if bot -> decide automatically
        if(player.isBot){
          await new Promise(r=>setTimeout(r, 400)); // slight delay
          const action = PK_botAction(player, PK_table);
          showLog(`${player.name} kiest ${action.type}${action.amount?(' '+action.amount):''}`);
          PK_applyAction(player, action);
          if(action.type === 'raise') { lastRaiser = player; PK_table.toCall = player.bet; }
          // move on
          idx = (idx+1)%PK_table.seats.length;
        } else {
          // human player: wait for UI input (resolve when user clicks call/raise/fold/allin)
          const act = await PK_waitHumanAction(player);
          if(!act) { /* timed out or aborted */ break; }
          showLog(`${player.name} kiest ${act.type}${act.amount?(' '+act.amount):''}`);
          PK_applyAction(player, act);
          if(act.type === 'raise') { lastRaiser = player; PK_table.toCall = player.bet; }
          idx = (idx+1)%PK_table.seats.length;
        }
        // check termination: if all players have bet equal to toCall or are all-in/folded
        let needMore = false;
        for(const p of PK_table.seats){
          if(!p || p.folded || p.allIn) continue;
          if((p.bet||0) !== PK_table.toCall) { needMore = true; break; }
        }
        if(!needMore) break;
      } // end while
      // betting round finished; normalize: add bets to committed, zero bet fields for next round
      for(const p of PK_table.seats){
        if(!p) continue;
        p.committed = (p.committed||0) + (p.bet||0);
        p.bet = 0;
      }
      // compute pots
      PK_table.potObjects = PK_calculatePots(PK_table.seats);
      PK_updatePotUI();
      PK_renderSeats();
      // proceed to next stage
      if(stage === 'preflop'){
        // deal flop
        PK_table.community.push(PK_table.deck.pop(), PK_table.deck.pop(), PK_table.deck.pop());
        PK_updateCommunity();
        // set toAct = first active seat after dealer
        PK_table.toAct = PK_nextOccupiedIndex(PK_table.dealerIndex, 1);
        setTimeout(()=>PK_runBettingRound('flop'), 300);
      } else if(stage === 'flop'){
        // turn
        PK_table.community.push(PK_table.deck.pop());
        PK_updateCommunity();
        PK_table.toAct = PK_nextOccupiedIndex(PK_table.dealerIndex, 1);
        setTimeout(()=>PK_runBettingRound('turn'), 300);
      } else if(stage === 'turn'){
        // river
        PK_table.community.push(PK_table.deck.pop());
        PK_updateCommunity();
        PK_table.toAct = PK_nextOccupiedIndex(PK_table.dealerIndex, 1);
        setTimeout(()=>PK_runBettingRound('river'), 300);
      } else if(stage === 'river'){
        // showdown
        PK_finishHand();
      }
    }

    // Wait for human action via UI - resolves to action object
    function PK_waitHumanAction(player){
      return new Promise(resolve=>{
        // enable buttons only for this human player
        PK_enableControls(true);
        const onFold = ()=>{ cleanup(); resolve({type:'fold'}); };
        const onCall = ()=>{ cleanup(); resolve({type:'call'}); };
        const onRaise = ()=>{ const amt = Math.max(1, parseInt(raiseInput.value)||0); cleanup(); resolve({type:'raise', amount:amt}); };
        const onAllin = ()=>{ cleanup(); resolve({type:'allin'}); };
        function cleanup(){
          foldBtn.removeEventListener('click', onFold);
          callBtn.removeEventListener('click', onCall);
          raiseBtn.removeEventListener('click', onRaise);
          allinBtn.removeEventListener('click', onAllin);
          PK_enableControls(false);
        }
        foldBtn.addEventListener('click', onFold);
        callBtn.addEventListener('click', onCall);
        raiseBtn.addEventListener('click', onRaise);
        allinBtn.addEventListener('click', onAllin);
      });
    }

    function PK_enableControls(enabled){
      foldBtn.disabled = !enabled;
      callBtn.disabled = !enabled;
      raiseBtn.disabled = !enabled;
      allinBtn.disabled = !enabled;
      raiseInput.disabled = !enabled;
    }

    // Apply action for player object
    function PK_applyAction(player, action){
      if(action.type === 'fold'){
        player.folded = true;
      } else if(action.type === 'call'){
        const need = PK_table.toCall - (player.bet||0);
        const put = Math.min(need, player.stack);
        player.stack -= put; player.bet = (player.bet||0) + put;
        if(player.stack===0) player.allIn = true;
      } else if(action.type === 'raise'){
        let raiseAmt = parseInt(action.amount)||0;
        // in no-limit, raise is amount total to add (we'll treat as raise over toCall)
        const need = PK_table.toCall - (player.bet||0);
        const totalPut = need + raiseAmt;
        const put = Math.min(totalPut, player.stack);
        player.stack -= put; player.bet = (player.bet||0) + put;
        if(player.stack===0) player.allIn = true;
        // update toCall
        PK_table.toCall = player.bet;
      } else if(action.type === 'allin'){
        const put = player.stack;
        player.bet = (player.bet||0) + put;
        player.stack = 0;
        player.allIn = true;
        if(player.bet > PK_table.toCall) PK_table.toCall = player.bet;
      }
      PK_renderSeats();
      PK_updateUI();
    }

    // Bot AI (level 3) - uses evaluator to estimate equity roughly and acts aggressively on strength
    function PK_botAction(player, tableState){
      // compute a simple strength: evaluate current best 7-card hand if community present,
      // otherwise estimate on hole cards highness.
      const community = tableState.community || [];
      const combined = [...player.hand, ...community];
      const rank = PK_evaluate7(combined); // higher array better
      const strength = PK_rankToScore(rank); // numeric [0..100]
      const toCallNeed = (tableState.toCall || 0) - (player.bet||0);
      const pot = PK_table.potObjects.reduce((a,b)=>a+b.amount,0) + (player.bet||0);
      // simple heuristics:
      // if very strong -> raise large
      if(strength >= 85 && player.stack > 0){
        const raise = Math.min(player.stack, Math.max( Math.floor(pot*0.5), Math.floor(player.stack*0.4) ));
        return { type:'raise', amount: Math.max(raise, 1) };
      }
      // medium strength -> call
      if(strength >= 40){
        if(toCallNeed === 0) return {type:'call'}; // check
        if(toCallNeed <= Math.floor(player.stack * 0.5)) return {type:'call'};
        // otherwise fold small chance
        if(Math.random() < 0.8) return {type:'call'}; else return {type:'fold'};
      }
      // weak hand preflop heuristics based on hole cards
      if(community.length===0){
        // premium pairs/AKs aggressive
        const v1 = PK_valNum(player.hand[0].value), v2 = PK_valNum(player.hand[1].value);
        const suited = player.hand[0].suit === player.hand[1].suit;
        if(v1 === v2 && v1 >= 10){ // high pocket pair
          const raise = Math.min(player.stack, Math.floor(player.stack*0.25));
          return {type:'raise', amount: Math.max(raise,1)};
        }
        if((v1===14 && v2>=10) || (v2===14 && v1>=10)){
          if(suited) return {type:'raise', amount: Math.min(player.stack, Math.floor(player.stack*0.2))};
          return {type:'call'};
        }
        // else fold to big bets
        if(toCallNeed > Math.floor(player.stack*0.1)) return {type:'fold'};
        return {type:'call'};
      }
      // default: fold small hands
      if(toCallNeed === 0) return {type:'call'}; // check
      if(toCallNeed > Math.floor(player.stack*0.2)) return {type:'fold'};
      if(Math.random()<0.3) return {type:'call'}; else return {type:'fold'};
    }

    // Convert evaluator rank to 0..100 score for bot heuristics
    function PK_rankToScore(rankArr){
      // rankArr: [category(8..0), tie1, tie2...]
      // map category to base score
      const cat = rankArr[0];
      const base = (cat/8) * 80; // 0..80
      // add tie breakers scaled down
      let t = 0;
      for(let i=1;i<rankArr.length;i++){ t += (rankArr[i] || 0) / (1000 * i); }
      return Math.min(99, Math.round(base + t*100));
    }

    // Calculate pots and side-pots
    function PK_calculatePots(seats){
      // seats: array of seat players (some null)
      const snapshot = seats.filter(s => s).map(p => ({ key:p.key, committed: p.committed || 0, folded: p.folded }));
      const pots = [];
      while(true){
        const contributors = snapshot.filter(s => s.committed > 0);
        if(contributors.length === 0) break;
        let min = Math.min(...contributors.map(c => c.committed));
        const potAmount = min * contributors.length;
        const eligibles = contributors.map(c => c.key);
        pots.push({ amount: potAmount, eligibles });
        for(const c of contributors) c.committed -= min;
      }
      return pots;
    }

    // Finish hand: evaluate showdown and pay pots
    function PK_finishHand(){
      // compute pots from seats (ensure committed includes current bets)
      for(const p of PK_table.seats){ if(p){ p.committed = (p.committed||0) + (p.bet||0); p.bet = 0; } }
      PK_table.potObjects = PK_calculatePots(PK_table.seats);
      PK_updatePotUI();
      // determine winners per pot
      const payoutLog = [];
      for(let i=0;i<PK_table.potObjects.length;i++){
        const pot = PK_table.potObjects[i];
        const eligiblePlayers = pot.eligibles.map(k => PK_table.seats.find(s=>s && s.key===k)).filter(x=>x && !x.folded);
        if(eligiblePlayers.length === 0){
          payoutLog.push({ potIndex:i, amount:pot.amount, winners:[], note:'nobody eligible' });
          continue;
        }
        // evaluate best rank for each eligible
        const ranks = eligiblePlayers.map(p => ({ p, rank: PK_evaluate7([...(p.hand||[]), ...PK_table.community]) }));
        // find best
        ranks.sort((a,b)=> PK_compareRank(a.rank,b.rank) ); // descending comparator returns negative if a better
        const bestRank = ranks[0].rank;
        const winners = ranks.filter(r => PK_compareRank(r.rank,bestRank) === 0).map(r=>r.p);
        // split pot
        const shareBase = Math.floor(pot.amount / winners.length);
        let rem = pot.amount - shareBase * winners.length;
        const wInfo = [];
        for(const w of winners){
          const share = shareBase + (rem>0?1:0);
          if(rem>0) rem--;
          w.stack += share;
          users[w.key].credits = (users[w.key].credits || 0) + share; // also reflect in users credit for persistence
          wInfo.push({ key:w.key, share });
        }
        payoutLog.push({ potIndex:i, amount:pot.amount, winners: wInfo });
      }
      // persist stacks to users where human seated
      for(const p of PK_table.seats){ if(p && users[p.key]) { users[p.key].credits = p.stack; users[p.key].totalEarned = users[p.key].totalEarned || 0; saveUsers(); } }
      showLog('Showdown complete. Uitbetalingen: ' + JSON.stringify(payoutLog));
      PK_renderSeats();
      PK_updateUI();
      // rotate dealer
      PK_table.dealerIndex = PK_nextOccupiedIndex(PK_table.dealerIndex, 1);
      PK_table.running = false;
    }

    // Utility: update UI elements for community and pot
    function PK_updateCommunity(){
      communityCardsDiv.innerHTML = '';
      for(const c of PK_table.community){
        const el = document.createElement('div'); el.className='card-pk'; el.textContent = PK_cardText(c); communityCardsDiv.appendChild(el);
      }
    }
    function PK_updatePotUI(){
      const pot = PK_table.potObjects.reduce((a,b)=>a+b.amount,0);
      pokerPotSpan.textContent = pot;
      pokerSidePotsSpan.textContent = PK_table.potObjects.length>1 ? PK_table.potObjects.slice(1).map(p=>p.amount).join(',') : '-';
    }
    function PK_updateUI(){
      PK_renderSeats();
      pokerPotSpan.textContent = PK_table.potObjects.reduce((a,b)=>a+b.amount,0) || 0;
      PK_updateCommunity();
    }

    // Evaluate 7-card hand -> returns rank array [category(8..0), tiebreakers...]
    // category: 8 straight flush,7 four,6 full house,5 flush,4 straight,3 trips,2 two pair,1 pair,0 high card
    function PK_evaluate7(cards){
      if(!cards || cards.length===0) return [0,0,0,0,0];
      // map value counts and suits
      const vals = cards.map(c => PK_valNum(c.value));
      // account for Ace as 1 as well
      const counts = {};
      const suits = {};
      for(const c of cards){
        const v = PK_valNum(c.value);
        counts[v] = (counts[v]||0)+1;
        suits[c.suit] = suits[c.suit] || [];
        suits[c.suit].push(v);
      }
      // helper to find flush
      let flushSuit = null;
      for(const s of Object.keys(suits)){
        if(suits[s].length >= 5){ flushSuit = s; break; }
      }
      // get unique sorted values desc
      const uniq = [...new Set(vals)].sort((a,b)=>b-a);
      // for straight detection include Ace low
      const uniqForStraight = [...new Set(vals.map(v=>v))];
      if(uniqForStraight.indexOf(14) !== -1) uniqForStraight.push(1);
      const uniqSortedAsc = [...new Set(uniqForStraight)].sort((a,b)=>a-b);
      // detect straight highest
      function findStraightHigh(arr){
        // arr sorted asc unique
        let maxHigh = -1;
        let run = 1;
        for(let i=1;i<arr.length;i++){
          if(arr[i] === arr[i-1] + 1) {
            run++;
            if(run>=5) maxHigh = Math.max(maxHigh, arr[i]);
          } else {
            run = 1;
          }
        }
        return maxHigh; // value of highest card in straight (numeric), -1 if none
      }
      const straightHigh = findStraightHigh(uniqSortedAsc);
      // straight flush detection
      let straightFlushHigh = -1;
      if(flushSuit){
        const valsFlush = suits[flushSuit]; // unsorted maybe
        const uniqF = [...new Set(valsFlush)];
        if(uniqF.indexOf(14)!==-1) uniqF.push(1);
        uniqF.sort((a,b)=>a-b);
        straightFlushHigh = findStraightHigh(uniqF);
      }
      // counts analysis for pairs/trips/quads
      const groups = [];
      for(const k of Object.keys(counts)){ groups.push({val:parseInt(k),count:counts[k]}); }
      groups.sort((a,b)=> b.count - a.count || b.val - a.val);
      const quads = groups.filter(g=>g.count===4).map(g=>g.val);
      const trips = groups.filter(g=>g.count===3).map(g=>g.val);
      const pairs = groups.filter(g=>g.count===2).map(g=>g.val);
      // build tiebreakers
      if(straightFlushHigh>0) return [8, straightFlushHigh];
      if(quads.length>0){
        const qv = quads[0];
        // kicker is highest other card
        const kicker = Math.max(...uniq.filter(v=>v!==qv));
        return [7, qv, kicker];
      }
      if(trips.length>0 && (pairs.length>0 || trips.length>1)){
        // full house: best trip + best pair (or second trip as pair)
        const tripv = trips[0];
        let pairv = pairs.length>0? pairs[0] : (trips[1]||0);
        return [6, tripv, pairv];
      }
      if(flushSuit){
        // best 5 values of flush suit
        const sortedFlushVals = suits[flushSuit].slice().sort((a,b)=>b-a);
        const top5 = sortedFlushVals.slice(0,5);
        return [5, ...top5];
      }
      if(straightHigh>0) return [4, straightHigh];
      if(trips.length>0){
        const tripv = trips[0];
        // kickers: highest other two cards
        const others = uniq.filter(v=>v!==tripv).sort((a,b)=>b-a).slice(0,2);
        return [3, tripv, ...others];
      }
      if(pairs.length>=2){
        const p1 = pairs[0], p2 = pairs[1];
        const kicker = uniq.filter(v=>v!==p1 && v!==p2).sort((a,b)=>b-a)[0];
        return [2, p1, p2, kicker];
      }
      if(pairs.length===1){
        const p = pairs[0];
        const kickers = uniq.filter(v=>v!==p).sort((a,b)=>b-a).slice(0,3);
        return [1, p, ...kickers];
      }
      // high card
      const top = uniq.sort((a,b)=>b-a).slice(0,5);
      return [0, ...top];
    }

    // Compare rank arrays: return -1 if a better than b, 1 if b better, 0 equal
    function PK_compareRank(a,b){
      // both arrays
      for(let i=0;i<Math.max(a.length,b.length);i++){
        const va = a[i]||0, vb = b[i]||0;
        if(va>vb) return -1;
        if(va<vb) return 1;
      }
      return 0;
    }

    /* ---------------------------
       Poker UI events & init
       --------------------------- */
    // initialize table seats
    PK_resetTable();
    // add bots automatically if you want? leave to user to join bots by code or we can prefill
    // For convenience, create a function to add bots to empty seats
    function PK_addBots(count){
      let added=0;
      for(let i=0;i<PK_table.seats.length && added<count;i++){
        if(!PK_table.seats[i]){
          const player = {
            key: 'bot'+(i+1),
            name: 'Bot '+(i+1),
            stack: parseInt(pokerStartStackInput.value)||1000,
            hand: [],
            bet:0,
            committed:0,
            folded:false,
            allIn:false,
            isBot:true,
            seat:i
          };
          PK_table.seats[i]=player; added++;
        }
      }
      PK_renderSeats();
    }

    // quick add bots button logic: when user joins, fill rest seats with bots up to selected max
    // We'll not auto-add here; user can call PK_addBots in console or you can click join multiple times
    // Wire UI controls for player actions
    foldBtn.onclick = ()=>{ /* handled in PK_waitHumanAction via listener */ };
    callBtn.onclick = ()=>{ /* handled in PK_waitHumanAction via listener */ };
    raiseBtn.onclick = ()=>{ /* handled in PK_waitHumanAction via listener */ };
    allinBtn.onclick = ()=>{ /* handled in PK_waitHumanAction via listener */ };

    // expose some helpers to console for debugging
    window.PK = {
      PK_addBots,
      PK_table,
      PK_evaluate7
    };

    /* ---------------------------
       End Poker module
       --------------------------- */

    // Init view
    loginSection.style.display='flex';
  </script>
</body>
</html>
